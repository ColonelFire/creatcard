<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Générateur de cartes TCG</title>
  <style>
    :root{
      --bg:#8C8C8C;             /* Fond du site corrigé (RAL #8C8C8C) */
      --ui:#0b3890;             /* Panneaux */
      --ui-2:#0f44a9;           /* En-têtes */
      --text:#ECF2FF;           /* Texte clair */
      --card-shadow: rgba(0,0,0,.35);
    }
    *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,Helvetica,sans-serif}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);display:flex;flex-direction:column}
    header{background:var(--ui-2);padding:10px 16px;font-weight:700;letter-spacing:.3px;box-shadow:0 2px 0 rgba(0,0,0,.2)}
    .app{display:grid;grid-template-columns:360px 1fr;gap:16px;padding:16px;min-height:0;flex:1}
    .panel{background:var(--ui);padding:12px;border-radius:12px;box-shadow:0 8px 30px var(--card-shadow);overflow:auto}
    .panel h2{margin:0 0 10px 0;font-size:18px}
    .group{margin-bottom:12px}
    .group label{display:block;font-size:12px;margin:0 0 6px 2px;opacity:.9}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    input[type="text"], input[type="number"], select, textarea{
      width:100%;border:1px solid rgba(255,255,255,.2);border-radius:8px;background:#0a2e73;color:var(--text);
      padding:10px;font-size:14px;outline:none
    }
    textarea{min-height:84px;resize:vertical}
    .btns{display:flex;gap:8px;flex-wrap:wrap}
    button{
      border:0;background:#173b97;color:#fff;padding:10px 12px;border-radius:10px;cursor:pointer;font-weight:600
    }
    button.secondary{background:#0a2e73}
    .preview{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      border-radius:12px;box-shadow:0 8px 30px var(--card-shadow);position:relative}
    canvas{display:block;max-width:100%;height:auto;box-shadow:0 18px 50px var(--card-shadow);background:#fff;border-radius:0}
    .foot{opacity:.8;margin-top:8px;font-size:12px}
    .zoombar{display:flex;gap:8px;align-items:center}
    .zoombar input[type=range]{flex:1}
    .badge{display:inline-block;background:#0a2e73;border:1px solid rgba(255,255,255,.2);padding:2px 6px;border-radius:6px;font-size:12px;margin-left:6px}
    .help{font-size:12px;opacity:.9;line-height:1.4}
  </style>
</head>
<body>
  <header>Générateur de cartes TCG – 63 × 89 mm (impression 300 DPI)</header>
  <div class="app">
    <div class="panel" id="controls">
      <h2>Paramètres</h2>

      <div class="group">
        <div class="row">
          <div>
            <label for="cadre">Cadre</label>
            <select id="cadre">
              <option value="gris">Gris (#515859)</option>
              <option value="noir">Noir (#0D0D0D)</option>
              <option value="invisible">Invisible</option>
            </select>
          </div>
          <div>
            <label for="rarete">Rareté</label>
            <select id="rarete">
              <option value="1">Commun</option>
              <option value="2">Peu Commune</option>
              <option value="3">Rare</option>
              <option value="4">Epic</option>
              <option value="5">Légendaire</option>
              <option value="6">Exclusif</option>
            </select>
          </div>
        </div>
      </div>

      <div class="group">
        <label for="nom">Nom (14 pt)</label>
        <input id="nom" type="text" placeholder="Nom de la créature" />
      </div>

      <div class="group row">
        <div>
          <label for="pv">PV (10 pt)</label>
          <input id="pv" type="text" placeholder="120" />
        </div>
        <div>
          <label for="extension">Extension (10 pt)</label>
          <input id="extension" type="text" placeholder="CL01" />
        </div>
      </div>

      <div class="group row">
        <div>
          <label for="illustrateur">Illustrateur (6 pt)</label>
          <input id="illustrateur" type="text" placeholder="Nom de l’illustrateur" />
        </div>
        <div>
          <label for="numero">Numéro (6 pt)</label>
          <input id="numero" type="text" placeholder="002/112" />
        </div>
      </div>

      <div class="group">
        <label for="description">Description & Attaque (10 pt – retour à la ligne auto)</label>
        <textarea id="description" placeholder="Texte de description et attaque…"></textarea>
      </div>

      <!-- === Statistiques (nouvelle section) === -->
      <div class="group">
        <label>Statistiques (8 pt)</label>
        <div class="row">
          <div>
            <label for="atk">Attaque</label>
            <input id="atk" type="number" placeholder="31" />
          </div>
          <div>
            <label for="def">Défense</label>
            <input id="def" type="number" placeholder="30" />
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <div>
            <label for="atkspd">Vit.Attaque</label>
            <input id="atkspd" type="number" placeholder="34" />
          </div>
          <div>
            <label for="defspd">Vit.Défense</label>
            <input id="defspd" type="number" placeholder="33" />
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <div>
            <label for="spd">Vitesse (bas de carte)</label>
            <input id="spd" type="number" placeholder="30" />
          </div>
        </div>
      </div>

      <div class="group">
        <label>Image (arrière-plan)</label>
        <div class="btns">
          <input type="file" id="file" accept="image/*" />
          <button id="resetImg" class="secondary">Réinitialiser l’image</button>
        </div>
        <div class="zoombar" style="margin-top:8px">
          <span>Zoom</span>
          <input id="zoom" type="range" min="0.2" max="3" step="0.01" value="1">
          <span id="zoomVal" class="badge">100%</span>
        </div>
        <p class="help">Glissez l’image directement sur la carte pour la repositionner. Molette = zoom fin.</p>
      </div>

      <div class="group btns">
        <button id="export">Télécharger PNG (300 DPI)</button>
        <button id="clear" class="secondary">Effacer tout</button>
      </div>

      <div class="foot">Astuce : les dimensions et marges sont calculées en millimètres selon vos contraintes (bordure 2,5 mm, zone texte 30 mm de haut, compartiments 10×7 mm avec angle 6×3 mm).</div>
    </div>

    <div class="preview">
      <!-- Canvas plein format (300 DPI) mais réduit visuellement pour l’aperçu -->
      <canvas id="card" width="744" height="1051"></canvas></canvas>
    </div>
  </div>

  <script>
  // === Constantes physiques ===
  const DPI = 300;                  // Export et rendu natif en 300 DPI
  const MM = DPI / 25.4;            // px par millimètre
  const CARD_W = Math.round(63 * MM);   // 63 mm → largeur
  const CARD_H = Math.round(89 * MM);   // 89 mm → hauteur
  const BORDER = 2.5 * MM;              // 2,5 mm cadre
  const BOX_W = 10 * MM, BOX_H = 7 * MM; // Compartiments 10×7 mm
  const NOTCH_SIDE = 6 * MM, NOTCH_TOP = 3 * MM; // biseau 6×3 mm
  const BLUE_H = 30 * MM;               // Zone "bleue" (texte) : 30 mm de haut

  // Couleurs
  const COLORS = {
    cadre: { gris: '#515859', noir: '#0D0D0D', invisible: null },
    zoneParRareté: {
      1: '#93BF34',   // Commun
      2: '#F2AE30',   // Peu Commune
      3: '#F25430',   // Rare
      4: '#F23030',   // Epic
      5: '#F26398',   // Légendaire
      6: '#04BF8A'    // Exclusif
    },
    coinsNoirs: '#0D0D0D'
  };

  // Conversion points → pixels (canvas à DPI constants)
  const pt = v => v * DPI / 72; // 1 pt = 1/72 in

  // Éléments DOM
  const c = document.getElementById('card');
  const ctx = c.getContext('2d');
  c.width = CARD_W; c.height = CARD_H;

  // Inputs
  const $ = id => document.getElementById(id);
  const inputs = {
    cadre: $('cadre'), rarete: $('rarete'), nom: $('nom'), pv: $('pv'), extension: $('extension'),
    illustrateur: $('illustrateur'), numero: $('numero'), description: $('description'),
    atk: $('atk'), atkspd: $('atkspd'), def: $('def'), defspd: $('defspd'), spd: $('spd'),
    file: $('file'), zoom: $('zoom'), zoomVal: $('zoomVal'), export: $('export'), clear: $('clear'), resetImg: $('resetImg')
  };

  // État image importée + déplacement/zoom
  let img = null;      // HTMLImageElement
  let imgPos = { x: CARD_W/2, y: CARD_H/2 }; // centre de l’image (en px carte)
  let imgScale = 1;    // facteur de zoom
  let dragging = false, dragStart = {x:0,y:0}, startPos={x:0,y:0};

  function loadImage(file){
    const reader = new FileReader();
    reader.onload = e => {
      const i = new Image();
      i.onload = () => { img = i; imgScale = 1; imgPos = { x: CARD_W/2, y: CARD_H/2 }; draw(); };
      i.src = e.target.result;
    };
    reader.readAsDataURL(file);
  }

  inputs.file.addEventListener('change', e => {
    if(e.target.files && e.target.files[0]) loadImage(e.target.files[0]);
  });

  inputs.resetImg.addEventListener('click', () => {
    imgScale = 1; imgPos = { x: CARD_W/2, y: CARD_H/2 }; draw();
  });

  // Drag
  c.addEventListener('pointerdown', e => {
    const rect = c.getBoundingClientRect();
    dragging = true;
    dragStart = { x: e.clientX - rect.left, y: e.clientY - rect.top };
    // convertir coords écran → coords canvas (selon taille CSS)
    const scale = c.width / rect.width;
    dragStart.x *= scale; dragStart.y *= scale;
    startPos = { ...imgPos };
    c.setPointerCapture(e.pointerId);
  });
  c.addEventListener('pointermove', e => {
    if(!dragging || !img) return;
    const rect = c.getBoundingClientRect();
    const scale = c.width / rect.width;
    const cur = { x: (e.clientX - rect.left) * scale, y: (e.clientY - rect.top) * scale };
    imgPos.x = startPos.x + (cur.x - dragStart.x);
    imgPos.y = startPos.y + (cur.y - dragStart.y);
    draw();
  });
  c.addEventListener('pointerup', e => { dragging = false; c.releasePointerCapture(e.pointerId); });

  // Molette = zoom fin
  c.addEventListener('wheel', e => {
    if(!img) return;
    e.preventDefault();
    const delta = -e.deltaY / 1000; // sens naturel
    imgScale = Math.min(3, Math.max(0.2, imgScale * (1 + delta)));
    inputs.zoom.value = imgScale.toFixed(2);
    inputs.zoom.dispatchEvent(new Event('input'));
  }, { passive:false });

  inputs.zoom.addEventListener('input', () => {
    imgScale = parseFloat(inputs.zoom.value);
    inputs.zoomVal.textContent = Math.round(imgScale*100)+"%";
    draw();
  });

  // Boutons
  inputs.export.addEventListener('click', () => {
    const url = c.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url; a.download = `carte_tcg_${Date.now()}.png`;
    a.click();
  });
  inputs.clear.addEventListener('click', () => {
    ['nom','pv','extension','illustrateur','numero','description'].forEach(id => $(id).value='');
    inputs.rarete.value='1'; inputs.cadre.value='gris'; img=null; draw();
  });

  // Redessin sur changement de paramètres
  ['input','change'].forEach(evt => {
    Object.values(inputs).forEach(el => { if(el && el.tagName){ el.addEventListener(evt, draw); } });
  });

  function drawFrame(color){
    if(!color) return; // cadre invisible
    ctx.fillStyle = color;
    // 4 côtés
    ctx.fillRect(0,0,CARD_W,BORDER);                         // haut
    ctx.fillRect(0,CARD_H-BORDER,CARD_W,BORDER);             // bas
    ctx.fillRect(0,0,BORDER,CARD_H);                         // gauche
    ctx.fillRect(CARD_W-BORDER,0,BORDER,CARD_H);             // droite
  }

  function drawHorizontalBar(color, y){
    if(!color) return;
    ctx.fillStyle = color;
    ctx.fillRect(BORDER, y - BORDER, CARD_W - 2*BORDER, BORDER);
  }

  function drawTopCornerCaps(){
    // Coins noirs supérieurs (pour raretés 4–6), stylisés comme deux "L" épais
    const t = BORDER;
    ctx.fillStyle = COLORS.coinsNoirs;
    // coin gauche
    ctx.fillRect(0,0, t*4, t); // bande horizontale
    ctx.fillRect(0,0, t, t*4); // bande verticale
    // coin droit
    ctx.fillRect(CARD_W - t*4, 0, t*4, t);
    ctx.fillRect(CARD_W - t, 0, t, t*4);
  }

  function drawCompartmentLeft(x,y,w,h, notchX, notchY){
    ctx.beginPath();
    ctx.moveTo(x+notchX, y);               // après biseau horizontal
    ctx.lineTo(x, y+notchY);               // biseau
    ctx.lineTo(x, y+h);
    ctx.lineTo(x+w, y+h);
    ctx.lineTo(x+w, y);
    ctx.closePath();
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.lineWidth = Math.max(1, BORDER*0.15);
    ctx.strokeStyle = 'rgba(0,0,0,.15)';
    ctx.stroke();
  }
  function drawCompartmentRight(x,y,w,h, notchX, notchY){
    ctx.beginPath();
    ctx.moveTo(x+w-notchX, y);            // avant biseau
    ctx.lineTo(x+w, y+notchY);            // biseau
    ctx.lineTo(x+w, y+h);
    ctx.lineTo(x, y+h);
    ctx.lineTo(x, y);
    ctx.closePath();
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.lineWidth = Math.max(1, BORDER*0.15);
    ctx.strokeStyle = 'rgba(0,0,0,.15)';
    ctx.stroke();
  }

  function wrapText(text, maxWidth, fontPx){
    const words = (text||'').split(/\s+/);
    const lines = [];
    let line = '';
    for(let w of words){
      const test = line ? line + ' ' + w : w;
      const metrics = ctx.measureText(test);
      if(metrics.width > maxWidth && line){
        lines.push(line);
        line = w;
      } else {
        line = test;
      }
    }
    if(line) lines.push(line);
    // Gestion des sauts de ligne manuels \n
    const out=[]; lines.join('\n').split('\n').forEach(l=>{ if(l!=='') out.push(l); else out.push('') });
    return out;
  }

  function draw(){
    // Effacer
    ctx.clearRect(0,0,CARD_W,CARD_H);

    // Fond blanc de la carte
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,CARD_W,CARD_H);

    // Image importée (arrière-plan, couvrant la carte mais librement positionnable)
    if(img){
      // Calcul pour couvrir la carte en préservant le ratio
      const scaleToCover = Math.max(CARD_W / img.width, CARD_H / img.height);
      const scale = scaleToCover * imgScale;
      const w = img.width * scale;
      const h = img.height * scale;
      const x = imgPos.x - w/2;
      const y = imgPos.y - h/2;
      ctx.drawImage(img, x, y, w, h);
    }

    // Cadre
    const cadreVal = inputs.cadre.value;                 // gris | noir | invisible
    const cadreColor = COLORS.cadre[cadreVal];
    drawFrame(cadreColor);

    // Limites internes (zone utile)
    const innerX = BORDER, innerY = BORDER;
    const innerW = CARD_W - 2*BORDER, innerH = CARD_H - 2*BORDER;

    // Compartiments (Extension et PV) collés en haut, à l'intérieur du cadre
    const boxY = innerY + 0; // plaqué en haut
    const leftBoxX  = innerX + 0;
    const rightBoxX = innerX + innerW - BOX_W;
    drawCompartmentLeft(leftBoxX, boxY, BOX_W, BOX_H, NOTCH_SIDE, NOTCH_TOP);
    drawCompartmentRight(rightBoxX, boxY, BOX_W, BOX_H, NOTCH_SIDE, NOTCH_TOP);

    // Texte des compartiments (10 pt)
    ctx.fillStyle = '#000';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `${pt(10)}px sans-serif`;
    ctx.fillText((inputs.extension.value||'').trim(), leftBoxX + BOX_W/2, boxY + BOX_H/2);
    ctx.fillText((inputs.pv.value||'').trim(), rightBoxX + BOX_W/2, boxY + BOX_H/2);

    // Zone texte ("bleue") collée en bas, pleine largeur intérieure, hauteur 30 mm
    const zoneX = innerX;
    const zoneW = innerW;
    const zoneH = BLUE_H;
    const zoneY = innerY + innerH - zoneH;

    // Couleur selon rareté
    const r = parseInt(inputs.rarete.value, 10);
    ctx.fillStyle = COLORS.zoneParRareté[r] || '#93BF34';
    ctx.fillRect(zoneX, zoneY, zoneW, zoneH);

    // Barre horizontale du cadre (au-dessus de la zone)
    drawHorizontalBar(cadreColor, zoneY);

    // Coins noirs supérieurs pour les raretés 4/5/6
    if(r >= 4) drawTopCornerCaps();

    // Nom (14 pt) – en haut de la zone
    const pad = 2 * MM; // marge interne
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillStyle = '#0D0D0D';
    ctx.font = `700 ${pt(14)}px sans-serif`;
    const nom = (inputs.nom.value || '').toUpperCase();
    const nameY = zoneY + pad;
    ctx.fillText(nom, zoneX + zoneW/2, nameY);

    // Description (10 pt), 1 mm sous le nom (pas de centrage vertical)
    const descTop = nameY + pt(14) + 1*MM; // 1 mm sous le nom
    const maxWidth = zoneW - pad*2;

    ctx.font = `${pt(10)}px sans-serif`;
    ctx.fillStyle = '#0D0D0D';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';

    const lines = wrapText(inputs.description.value || '', maxWidth, pt(10));
    const lineHeight = pt(10) * 1.25;
    let y = descTop;
    for(const line of lines){
      ctx.fillText(line, zoneX + zoneW/2, y);
      y += lineHeight;
    }

    // Statistiques (8 pt) sous la description
    const statsTop = y + 1*MM; // 1 mm sous la description
    const lhSmall = pt(8) * 1.25;
    ctx.font = `${pt(8)}px sans-serif`;
    ctx.fillStyle = '#0D0D0D';

    // Colonne gauche : Attaque & Vitesse d'Attaque (alignée à gauche)
    ctx.textAlign = 'left';
    ctx.fillText(`Attaque : ${ (inputs.atk.value||'').toString() }`, zoneX + pad, statsTop);
    ctx.fillText(`Vitesse d'Attaque : ${ (inputs.atkspd.value||'').toString() }`, zoneX + pad, statsTop + lhSmall);

    // Colonne droite : Défense & Vitesse de Défense (alignée à droite)
    ctx.textAlign = 'right';
    ctx.fillText(`Défense : ${ (inputs.def.value||'').toString() }`, zoneX + zoneW - pad, statsTop);
    ctx.fillText(`Vitesse de Défense : ${ (inputs.defspd.value||'').toString() }`, zoneX + zoneW - pad, statsTop + lhSmall);

    // Mentions bas de carte (6 pt) à 1 mm des bords intérieur gauche/droite et du bas
    const m = 1 * MM; // marge
    ctx.font = `${pt(6)}px sans-serif`;
    ctx.fillStyle = '#0D0D0D';
    ctx.textBaseline = 'alphabetic';
    ctx.textAlign = 'left';
    const illu = (inputs.illustrateur.value||'').trim();
    ctx.fillText(illu, BORDER + m, CARD_H - BORDER - m);

    ctx.textAlign = 'right';
    const num = (inputs.numero.value||'').trim();
    ctx.fillText(num, CARD_W - BORDER - m, CARD_H - BORDER - m);

    // Vitesse (8 pt, centré)
    ctx.textAlign = 'center';
    ctx.font = `${pt(8)}px sans-serif`;
    const spd = (inputs.spd.value||'').toString();
    if(spd){ ctx.fillText(`Vitesse : ${spd}`, CARD_W/2, CARD_H - BORDER - m); }
  }

  // Ajuste l'aperçu pour garantir le bon ratio 63:89 quelle que soit la taille de la fenêtre
  function setPreviewSize(){
    const container = document.querySelector('.preview');
    const maxW = Math.min(372, (container?.clientWidth||372) - 20);
    const cssW = Math.max(240, maxW);
    c.style.width  = cssW + 'px';
    c.style.height = (cssW * 89 / 63) + 'px';
  }
  window.addEventListener('resize', () => { setPreviewSize(); });

  // Premier rendu
  setPreviewSize();
  draw();
  </script>
</body>
</html>
